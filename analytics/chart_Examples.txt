
animated sunburst

import React from 'react';

import {Sunburst} from 'index';

import ShowcaseButton from '../showcase-components/showcase-button';

function randomLeaf() {

  return {

    size: Math.random() * 1000,

    color: Math.random()

  };

}

function updateData() {

  const totalLeaves = Math.random() * 20;

  const leaves = [];

  for (let i = 0; i < totalLeaves; i++) {

    const leaf = randomLeaf();

    if (Math.random() > 0.8) {

      leaf.children = [...new Array(3)].map(() => randomLeaf());

    }

    leaves.push(leaf);

  }

  return {

    title: '',

    color: 1,

    children: leaves

  };

}

const DIVERGING_COLOR_SCALE = ['#00939C', '#85C4C8', '#EC9370', '#C22E00'];

export default class AnimatedSunburst extends React.Component {

  state = {

    data: updateData(),

    hovering: false

  };

  render() {

    const {data, hovering} = this.state;

    return (

      <div className="animated-sunburst-example-wrapper">

        <ShowcaseButton

          onClick={() => this.setState({data: updateData()})}

          buttonContent={'UPDATE'}

        />

        <div>{hovering ? 'CURRENTLY HOVERING' : 'NOT HOVERED'}</div>

        <Sunburst

          animation={{damping: 20, stiffness: 300}}

          data={data}

          colorType={'category'}

          colorRange={DIVERGING_COLOR_SCALE}

          style={{stroke: '#fff'}}

          onValueMouseOver={() => this.setState({hovering: true})}

          onValueMouseOut={() => this.setState({hovering: false})}

          height={300}

          width={350}

        />

      </div>

    );

  }

}

responsive bar:

import React from 'react';

import {AreaSeries, HorizontalBarSeries, XAxis, XYPlot, YAxis} from 'index';

import {filterFeatures, getPPP} from './responsive-vis-utils';

// range constants

const VERY_LOW_RANGE = [0, 0.08];

const LOW_RANGE = [0, 0.7];

const HIGH_RANGE = [0.7, Infinity];

export const BARCHART_FEATURES = [

  {min: -Infinity, max: Infinity, name: 'xaxis', group: 0},

  {min: VERY_LOW_RANGE[0], max: VERY_LOW_RANGE[1], name: 'yaxis', group: 1},

  {min: LOW_RANGE[0], max: LOW_RANGE[1], name: 'bars', group: 2},

  {min: HIGH_RANGE[0], max: HIGH_RANGE[1], name: 'area', group: 2}

];

function updateDataForArea(data, ppp) {

  // Use the PPP ratio as the step to sample the data

  const step = Math.round(ppp);

  const sample = [];

  let index = data.length - 1;

  while (index >= 0) {

    const dataPoint = data[index];

    sample.unshift({...dataPoint, y: sample.length - 1});

    index -= step;

  }

  return sample;

}

export default class ResponsiveBarChart extends React.Component {

  // todo build a root responsive class that has this as a class method

  getFeatures() {

    const {data, height, margin, width} = this.props;

    const innerWidth = width - margin.left - margin.right;

    const innerHeight = height - margin.top - margin.bottom;

    const ppp = getPPP(innerWidth, innerHeight, data, 'HEIGHT');

    return filterFeatures(BARCHART_FEATURES, ppp);

  }

  render() {

    const {data, height, margin, width} = this.props;

    const innerWidth = width - margin.left - margin.right;

    const innerHeight = height - margin.top - margin.bottom;

    const ppp = getPPP(innerWidth, innerHeight, data, 'HEIGHT');

    const featuresToRender = filterFeatures(BARCHART_FEATURES, ppp);

    const updatedData = featuresToRender.area

      ? updateDataForArea(data, ppp)

      : data;

    return (

      <div className="responsive-bar-chart">

        <XYPlot

          yType="ordinal"

          xType="linear"

          margin={margin}

          height={height}

          width={width}

        >

          {featuresToRender.xaxis && <XAxis orientation="top" />}

          {featuresToRender.yaxis && <YAxis />}

          {featuresToRender.bars && (

            <HorizontalBarSeries

              colorType="literal"

              yRange={[0, innerHeight]}

              xRange={[0, innerWidth]}

              data={updatedData}

            />

          )}

          {featuresToRender.area && (

            <AreaSeries

              colorType="literal"

              color="#12939A"

              yType="linear"

              yDomain={[0, updatedData.length]}

              yRange={[0, innerHeight]}

              xRange={[innerWidth, 0]}

              data={updatedData}

            />

          )}

        </XYPlot>

      </div>

    );

  }

}

Advanced hover:

function CustomArea(props) {
  if (!props.active) {
    return <Area {...props} />;
  } else {
    const { data, activeX, scale, style } = props;
    const index = data.findIndex(val => val._x.getTime() === activeX.getTime());
    const previousPoint = index === 0 ? activeX : data[index - 1]._x;
    const nextPoint = index === data.length - 1 ? activeX : data[index + 1]._x;
    // create a copy of the x dimension scale, and set the range to [0, 100] to easily calculate a percentage for the gradient offsets
    const percentScale = scale.x.copy().range([0, 100]);
    // calculate the percentages for current, previous, and next points
    const currentPercent = percentScale(activeX);
    const previousPercent = percentScale(previousPoint);
    const nextPercent = percentScale(nextPoint);
    const minPercent = currentPercent - (currentPercent - previousPercent) / 2;
    const maxPercent = currentPercent + (nextPercent - currentPercent) / 2;

    const gradientId = Math.random();
    const isBrowser =
      typeof window !== "undefined" && window.__STATIC_GENERATOR !== true;
    const loc = isBrowser ? window.location.href : "";
    const newStyle = Object.assign({}, style, {
      fill: `url(${loc}#${gradientId})`,
      stroke: "none"
    });

    return (
      <g>
        <defs>
          <linearGradient id={gradientId}>
            <stop offset="0%" stopColor={style.fill} />
            <stop offset={`${minPercent}%`} stopColor={style.fill} />
            <stop offset={`${minPercent}%`} stopColor={"tomato"} />
            <stop offset={`${maxPercent}%`} stopColor={"tomato"} />
            <stop offset={`${maxPercent}%`} stopColor={style.fill} />
            <stop offset="100%" stopColor={style.fill} />
          </linearGradient>
        </defs>
        <Area {...props} style={newStyle} />
      </g>
    );
  }
}

function App() {
  const [state, setState] = React.useState({
    activeX: null
  });

  function onActivated(points, props) {
    setState({ activeX: points[0]._x });
  }

  return (
    <VictoryChart
      scale={{ x: "time" }}
      containerComponent={
        <VictoryVoronoiContainer onActivated={onActivated} />
      }
      theme={VictoryTheme.clean}
    >
      <VictoryStack colorScale="blue">
        <VictoryArea
          data={[
            { x: new Date(1986, 1, 1), y: 2 },
            { x: new Date(1996, 1, 1), y: 3 },
            { x: new Date(2006, 1, 1), y: 5 },
            { x: new Date(2016, 1, 1), y: 4 }
          ]}
          dataComponent={<CustomArea activeX={state.activeX} />}
        />

        <VictoryArea
          data={[
            { x: new Date(1986, 1, 1), y: 4 },
            { x: new Date(1996, 1, 1), y: 3 },
            { x: new Date(2006, 1, 1), y: 2 },
            { x: new Date(2016, 1, 1), y: 5 }
          ]}
          dataComponent={<CustomArea activeX={state.activeX} />}
        />
        <VictoryArea
          data={[
            { x: new Date(1986, 1, 1), y: 3 },
            { x: new Date(1996, 1, 1), y: 1 },
            { x: new Date(2006, 1, 1), y: 4 },
            { x: new Date(2016, 1, 1), y: 2 }
          ]}
          dataComponent={<CustomArea activeX={state.activeX} />}
        />
      </VictoryStack>
    </VictoryChart>
  );
}

render(<App/>);

import { ResponsiveChord } from '@nivo/chord'

const MyChord = ({ data /* see data tab */ }) => (
    <ResponsiveChord /* or Chord for fixed dimensions */
        data={data}
        keys={['John', 'Raoul', 'Jane', 'Marcel', 'Ibrahim']}
        margin={{ top: 60, right: 60, bottom: 90, left: 60 }}
        padAngle={0.06}
        legends={[
            {
                anchor: 'bottom',
                direction: 'row',
                translateY: 70,
                itemWidth: 80,
                itemHeight: 16,
                symbolShape: 'circle'
            }
        ]}
    />
)


import React from 'react';

import {
  XYPlot,
  XAxis,
  YAxis,
  HorizontalGridLines,
  VerticalGridLines,
  LineSeries
} from 'index';

const data = [];

for (let i = 0; i < 20; i++) {
  const series = [];
  for (let j = 0; j < 100; j++) {
    series.push({x: j, y: (i / 10 + 1) * Math.sin((Math.PI * (i + j)) / 50)});
  }
  data.push({color: i, key: i, data: series, opacity: 0.8});
}

export default function Example() {
  return (
    <XYPlot
      width={300}
      height={300}
      colorType="linear"
      colorDomain={[0, 9]}
      colorRange={['yellow', 'orange']}
    >
      <HorizontalGridLines />
      <VerticalGridLines />
      <XAxis />
      <YAxis />
      {data.map(props => (
        <LineSeries {...props} />
      ))}
    </XYPlot>
  );
}import React from 'react';

import {XYPlot, ArcSeries} from 'index';

import {EXTENDED_DISCRETE_COLOR_RANGE} from 'theme';

const PI = Math.PI;

function getSeconds() {
  return Math.floor(new Date().getTime() / 1000);
}

export default class ClockExample extends React.Component {
  state = {
    time: 0
  };

  componentDidMount() {
    this._timerId = setInterval(() => this.setState({time: getSeconds()}), 100);
  }

  componentWillUnmount() {
    clearInterval(this._timerId);
    this.setState({timerId: false});
  }

  render() {
    const {time} = this.state;
    const seconds = time % 60;
    const minutes = (time / 60) % 60;
    const hours = (time / (60 * 24)) % 24;
    return (
      <XYPlot
        xDomain={[-3, 3]}
        yDomain={[-3, 3]}
        width={300}
        getAngle={d => d.time}
        getAngle0={d => 0}
        height={300}
      >
        <ArcSeries
          animation={{
            damping: 9,
            stiffness: 300
          }}
          radiusDomain={[0, 3]}
          data={[
            {time: (seconds / 60) * 2 * PI, radius0: 1, radius: 1.5, color: 0},
            {
              time: (minutes / 60) * 2 * PI,
              radius0: 1.6,
              radius: 2.1,
              color: 1
            },
            {time: (hours / 24) * 2 * PI, radius0: 2.2, radius: 2.7, color: 2}
          ]}
          colorRange={EXTENDED_DISCRETE_COLOR_RANGE}
        />
      </XYPlot>
    );
  }
}



import React from 'react';
import {
  XYPlot,
  MarkSeries,
  HeatmapSeries,
  XAxis,
  YAxis,
  Hint,
  LabelSeries
} from 'index';

import {
  filterFeatures,
  computeRadius,
  getPPP,
  transformToBinData,
  manicureData
} from './responsive-vis-utils';

// range constants
const SUPER_LOW_RANGE = [0, 1e-4];
const VERY_LOW_RANGE = [0, 8e-4];
const LOW_RANGE = [0, 5e-3];
const MED_LOW_RANGE = [1e-4, 5e-3];
const MED_RANGE = [5e-3, 1e-2];
const HIGH_RANGE = [1e-2, Infinity];
const MED_HIGH_RANGE = [MED_RANGE[0], HIGH_RANGE[1]];

export const SCATTERPLOT_FEATURES = [
  {min: -Infinity, max: Infinity, name: 'axes', group: 0},
  {min: SUPER_LOW_RANGE[0], max: SUPER_LOW_RANGE[1], name: 'labels', group: 1},
  {
    min: VERY_LOW_RANGE[0],
    max: VERY_LOW_RANGE[1],
    name: 'pointSelection',
    group: 1
  },
  {min: LOW_RANGE[0], max: LOW_RANGE[1], name: 'points', group: 3},
  {min: MED_LOW_RANGE[0], max: MED_LOW_RANGE[1], name: 'tooltips', group: 2},
  {min: MED_HIGH_RANGE[0], max: MED_HIGH_RANGE[1], name: 'bins', group: 3},
  {min: MED_HIGH_RANGE[0], max: MED_HIGH_RANGE[1], name: 'bintips', group: 2},
  {
    min: MED_HIGH_RANGE[0],
    max: MED_HIGH_RANGE[1],
    name: 'binSelection',
    group: 1
  }
];

export default class ResponsiveScatterplot extends React.Component {
  state = {
    binData: [],
    hoveredPoint: false,
    selectedPoints: []
  };

  componentWillReceiveProps(nextProps) {
    // not the greatest
    this.setState({
      binData: transformToBinData(
        nextProps.data,
        nextProps.width,
        nextProps.height
      )
    });
  }

  getFeatures() {
    const {data, height, margin, width} = this.props;
    const innerWidth = width - margin.left - margin.right;
    const innerHeight = height - margin.top - margin.bottom;
    const ppp = getPPP(innerWidth, innerHeight, data, 'HEIGHT');
    return filterFeatures(SCATTERPLOT_FEATURES, ppp);
  }

  _select(accessor) {
    return (value, e) => {
      e.event.stopPropagation();
      let foundValue = false;

      const selectedPoints = this.state.selectedPoints.filter(row => {
        if (accessor(row) === accessor(value)) {
          foundValue = true;
        }
        return accessor(row) !== accessor(value);
      });

      if (!foundValue) {
        selectedPoints.push(value);
      }

      this.setState({selectedPoints});
    };
  }

  render() {
    const {binData, hoveredPoint, selectedPoints} = this.state;
    const {data, height, margin, width} = this.props;
    const innerWidth = width - margin.left - margin.right;
    const innerHeight = height - margin.top - margin.bottom;

    const ppp = getPPP(innerWidth, innerHeight, data, 'TWOD');
    const featuresToRender = filterFeatures(SCATTERPLOT_FEATURES, ppp);
    const rememberVal =
      featuresToRender.pointSelection || featuresToRender.tooltips;
    const rememberBin =
      featuresToRender.bintips || featuresToRender.binSelection;

    const pointRadii = computeRadius(data, innerWidth, innerHeight);

    const showHint =
      (featuresToRender.tooltips || featuresToRender.bintips) && hoveredPoint;
    return (
      <div className="responsive-vis">
        <XYPlot height={height} margin={margin} width={width}>
          {featuresToRender.axes && <XAxis />}
          {featuresToRender.axes && <YAxis />}
          {featuresToRender.bins && (
            <HeatmapSeries
              className="responsive-vis-heatmap"
              colorType="literal"
              onValueMouseOver={
                rememberBin
                  ? value => this.setState({hoveredPoint: value})
                  : null
              }
              onValueMouseOut={
                rememberBin ? () => this.setState({hoveredPoint: null}) : null
              }
              onValueClick={
                featuresToRender.binSelection
                  ? this._select(d => `${d.x}-${d.y}`)
                  : null
              }
              data={manicureData(binData, hoveredPoint, selectedPoints, true)}
            />
          )}
          {featuresToRender.points && (
            <MarkSeries
              className="responsive-vis-scatterplot"
              colorType="literal"
              size={pointRadii}
              onValueMouseOver={
                rememberVal
                  ? value => this.setState({hoveredPoint: value})
                  : null
              }
              onValueMouseOut={
                rememberVal ? () => this.setState({hoveredPoint: null}) : null
              }
              onValueClick={
                featuresToRender.pointSelection
                  ? this._select(d => d.label)
                  : null
              }
              data={manicureData(data, hoveredPoint, selectedPoints, false)}
            />
          )}
          {showHint && <Hint value={hoveredPoint} />}
          {featuresToRender.labels && (
            <LabelSeries
              allowOffsetToBeReversed
              data={data}
              yOffset={-1 * pointRadii}
            />
          )}
        </XYPlot>
      </div>
    );
  }
}



import * as d3 from 'https://cdn.jsdelivr.net/npm/d3@7/+esm';
// import * as CP from './counterpoint-vis.es.js';
import * as CP from 'https://cdn.jsdelivr.net/npm/counterpoint-vis@latest/dist/counterpoint-vis.es.js';

// Declare the chart dimensions and margins.
let width = 600;
let height = 600;
const marginTop = 60;
const marginRight = 0;
const marginBottom = 60;
const marginLeft = 60;

const MinYear = 1952;
const MaxYear = 2007;
const StartYear = 1992;

const AxisLabels = {
  gdp_cap: 'GDP Per Capita',
  life_exp: 'Life Expectancy (yr)',
  population: 'Population',
};

const ScaleTypes = {
  gdp_cap: 'log',
  life_exp: 'linear',
  population: 'log',
};

function createAxes(scales, xEncoding, yEncoding) {
  // Create the SVG container.
  const svg = d3.select('#gapminder-axes');
  if (svg.empty()) return;
  let rect = d3
    .select('#gapminder-chart-container')
    .node()
    .getBoundingClientRect();
  svg.attr('width', rect.width).attr('height', rect.height);
  svg.selectAll('*').remove();

  // We portray the axes as log scales when needed and convert the extents
  let xScale, yScale;
  if (ScaleTypes[xEncoding] == 'log')
    xScale = d3.scaleLog(
      scales.xScale.domain().map((x) => Math.pow(10, x)),
      scales.xScale.range()
    );
  else xScale = d3.scaleLinear(scales.xScale.domain(), scales.xScale.range());

  if (ScaleTypes[yEncoding] == 'log')
    yScale = d3.scaleLog(
      scales.yScale.domain().map((x) => Math.pow(10, x)),
      scales.yScale.range()
    );
  else yScale = d3.scaleLinear(scales.yScale.domain(), scales.yScale.range());

  svg
    .append('g')
    .style('font-size', '10pt')
    .attr('transform', `translate(0,${height - marginBottom})`)
    .call(d3.axisBottom(xScale).tickArguments([5, ',.6~s']))
    .call((g) =>
      g
        .append('text')
        .attr('x', width - marginRight)
        .attr('y', 40)
        .attr('fill', 'currentColor')
        .attr('text-anchor', 'end')
        .text(`${AxisLabels[xEncoding]} →`)
    );
  svg
    .append('g')
    .selectAll('line')
    .data(xScale.ticks(5))
    .join('line')
    .attr('x1', (d) => xScale(d))
    .attr('x2', (d) => xScale(d))
    .attr('y1', marginTop)
    .attr('y2', height - marginBottom)
    .attr('stroke', '#f0f0f0')
    .attr('stroke-width', '1');

  // Add the y-axis.
  svg
    .append('g')
    .style('font-size', '10pt')
    .attr('transform', `translate(${marginLeft},0)`)
    .call(d3.axisLeft(yScale).tickArguments([5, ',.6~s']))
    .call((g) =>
      g
        .append('text')
        .attr('x', -marginLeft)
        .attr('y', marginTop - 20)
        .attr('fill', 'currentColor')
        .attr('text-anchor', 'start')
        .text(`↑ ${AxisLabels[yEncoding]}`)
    );
  svg
    .append('g')
    .attr('class', 'grid-lines')
    .selectAll('line')
    .data(yScale.ticks(5))
    .join('line')
    .attr('x1', marginLeft)
    .attr('x2', width - marginRight)
    .attr('y1', (d) => yScale(d))
    .attr('y2', (d) => yScale(d))
    .attr('stroke', '#f0f0f0')
    .attr('stroke-width', '1');
}

function drawCanvas(canvas, bubbleSet, lineSet) {
  const ctx = canvas.getContext('2d');

  // scaling for 2x devices
  ctx.resetTransform();
  ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
  ctx.clearRect(0, 0, width, height);

  // clip to chart bounds
  ctx.beginPath();
  ctx.rect(
    marginLeft,
    marginTop,
    width - marginLeft - marginRight,
    height - marginTop - marginBottom
  );
  ctx.clip();
  ctx.closePath();
  ctx.textAlign = 'center';
  ctx.textBaseline = 'bottom';

  if (lineSet.stage.count() > 0) {
    ctx.save();
    // draw a shadow of the bubble's position and size using a series of
    // rounded paths
    ctx.fillStyle = '#e0e0e0';
    lineSet.stage.forEach((mark) => {
      ctx.globalAlpha = mark.attr('alpha');
      let xCoords = mark.attr('x');
      let yCoords = mark.attr('y');
      let sizes = mark.attr('size');
      for (let i = 0; i < xCoords.length - 1; i++) {
        let x0 = xCoords[i],
          x1 = xCoords[i + 1],
          y0 = yCoords[i],
          y1 = yCoords[i + 1],
          s0 = sizes[i],
          s1 = sizes[i + 1];
        ctx.save();
        ctx.translate(x0, y0);
        ctx.rotate(Math.atan2(y1 - y0, x1 - x0));
        ctx.beginPath();
        let dist = Math.sqrt(Math.pow(y1 - y0, 2) + Math.pow(x1 - x0, 2));
        ctx.ellipse(0, 0, s0, s0, 0, -Math.PI * 0.5, Math.PI * 0.5, true);
        ctx.lineTo(dist, s1, dist);
        ctx.ellipse(dist, 0, s1, s1, 0, Math.PI * 0.5, -Math.PI * 0.5, true);
        ctx.lineTo(0, -s0);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }

      // draw a constant-width line on top
      ctx.beginPath();
      ctx.strokeStyle = '#bbb';
      ctx.lineWidth = 3.0;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.moveTo(xCoords[0], yCoords[0]);
      for (let i = 1; i < xCoords.length; i++) {
        ctx.lineTo(xCoords[i], yCoords[i]);
      }
      ctx.stroke();
    });
    ctx.restore();
  }

  bubbleSet.forEach((mark) => {
    ctx.save();
    let alpha = mark.attr('alpha');
    ctx.globalAlpha = alpha;
    ctx.fillStyle = '#4682b455';
    ctx.beginPath();
    let r = mark.attr('radius'),
      x = mark.attr('x'),
      y = mark.attr('y');
    ctx.ellipse(x, y, r, r, 0, 0, 2 * Math.PI);
    ctx.fill();
    let strokeWidth = mark.attr('strokeWidth');
    ctx.strokeStyle = '#4682b4';
    ctx.lineWidth = strokeWidth;
    ctx.stroke();
    ctx.closePath();
    ctx.restore();

    let labelSize = mark.attr('labelSize');
    if (labelSize > 1) {
      ctx.save();
      ctx.font = `${labelSize.toFixed(2)}pt sans-serif`;
      ctx.strokeStyle = 'white';
      ctx.lineWidth = Math.round(0.25 * labelSize);
      ctx.fillStyle = 'black';
      ctx.strokeText(mark.id, x, y - r - 4);
      ctx.fillText(mark.id, x, y - r - 4);
      ctx.restore();
    }
  });
}

// interpolates between available year data
function interpolateVariable(getter, countryData, year) {
  let lowerYear = Array.from(countryData.keys()).reduce(
    (a, b) => (b > year ? a : Math.max(a, b)),
    0
  );
  let upperYear = Array.from(countryData.keys()).reduce(
    (a, b) => (b < year ? a : Math.min(a, b)),
    1e9
  );
  if (!countryData.has(lowerYear) && !countryData.has(upperYear)) return 0;
  if (!countryData.has(lowerYear)) return getter(countryData.get(upperYear));
  if (!countryData.has(upperYear)) return getter(countryData.get(lowerYear));
  if (lowerYear == upperYear) return getter(countryData.get(lowerYear));
  return (
    (getter(countryData.get(lowerYear)) * (upperYear - year)) /
      (upperYear - lowerYear) +
    (getter(countryData.get(upperYear)) * (year - lowerYear)) /
      (upperYear - lowerYear)
  );
}

// returns a set of coordinates for points falling between the start and end years
function lineCoordinates(getter, countryData, startYear, endYear) {
  let years = [
    startYear,
    ...Array.from(countryData.keys()).filter(
      (y) => y >= startYear && y <= endYear
    ),
    endYear,
  ];
  return years.map((y) => interpolateVariable(getter, countryData, y));
}

function nearestBubbleContainingPos(positionMap, mousePos, maxDistance) {
  let nearest = positionMap.marksNear(mousePos, maxDistance);
  if (nearest.length == 0) return null;
  else {
    // find the mark for which the mouse pos is within the bubble
    let markWithinBounds = nearest.find(
      (m) =>
        Math.sqrt(
          Math.pow(m.attr('x') - mousePos[0], 2) +
            Math.pow(m.attr('y') - mousePos[1], 2)
        ) <= m.attr('radius')
    );
    if (!!markWithinBounds) return markWithinBounds.id;
    return null;
  }
}

export function loadGapminderPlot() {
  d3.csv('/counterpoint/assets/gapminder/gapminder_full.csv').then((data) => {
    let canvas = document.getElementById('gapminder-content');
    let slider = document.getElementById('year-slider');
    if (!canvas) return;

    // format dataset - apply log10 for logarithmic fields
    data.forEach((d) => {
      d.year = parseInt(d.year);
      d.population = Math.log10(parseInt(d.population));
      d.life_exp = parseFloat(d.life_exp);
      d.gdp_cap = Math.log10(parseFloat(d.gdp_cap));
    });
    let allCountries = Array.from(new Set(data.map((d) => d.country)));
    allCountries.sort();
    let perCountryData = new Map(
      allCountries.map((country) => [
        country,
        new Map(
          data.filter((d) => d.country == country).map((d) => [d.year, d])
        ),
      ])
    );

    let currentYear = new CP.Attribute(StartYear);
    let xEncoding = 'life_exp';
    let yEncoding = 'gdp_cap';
    let sizeEncoding = 'population';
    let xGet = (datum) => datum[xEncoding];
    let yGet = (datum) => datum[yEncoding];
    // cancel out the log transform for size
    let sizeGet = (datum) =>
      ScaleTypes[sizeEncoding] == 'log'
        ? Math.pow(10, datum[sizeEncoding])
        : datum[sizeEncoding];

    let hoveredCountry = null;
    let selectedCountry = null;

    // create scales, which handle transforming the coordinates and zooming to
    // particular marks when we select
    let scales = new CP.Scales().onUpdate(() => {
      // When the scales update, we also need to let the d3 zoom object know that
      // the zoom transform has changed. Otherwise performing a zoom gesture after
      // a programmatic update will result in an abrupt transform change
      let sel = d3.select(canvas);
      let currentT = d3.zoomTransform(canvas);
      let t = scales.transform();
      if (t.k != currentT.k || t.x != currentT.x || t.y != currentT.y) {
        sel.call(zoom.transform, new d3.ZoomTransform(t.k, t.x, t.y));
      }
      createAxes(scales, xEncoding, yEncoding);
      positionMap.invalidate();
    });

    // for bubble size, use a simple d3 scale
    let sizeScale = d3.scaleSqrt().range([4, 60]);

    function updateDomains() {
      scales.xDomain(d3.extent(data, xGet), false);
      scales.yDomain(d3.extent(data, yGet), false);
      sizeScale = sizeScale.domain(d3.extent(data, sizeGet));
    }
    updateDomains();

    function updateRanges(animated) {
      width = canvas.offsetWidth;
      height = canvas.offsetHeight;
      canvas.width = canvas.offsetWidth * window.devicePixelRatio;
      canvas.height = canvas.offsetHeight * window.devicePixelRatio;
      scales
        .xRange([marginLeft, width - marginRight], animated)
        .yRange([height - marginBottom, marginTop], animated);
    }
    updateRanges(false);

    // create a render group with all bubbles
    let bubbleSet = new CP.MarkRenderGroup(
      allCountries.map(
        (country) =>
          new CP.Mark(country, {
            year: () => currentYear.get(),
            x: (mark) => {
              let v = interpolateVariable(
                xGet,
                perCountryData.get(country),
                mark.attr('year')
              );
              // here we use the scale within the value fn, not as a transform,
              // because we want the transform to animate as well even if it
              // undergoes a discrete change (such as linear <> log)
              return scales.xScale(v);
            },
            y: (mark) => {
              let v = interpolateVariable(
                yGet,
                perCountryData.get(country),
                mark.attr('year')
              );
              return scales.yScale(v);
            },
            radius: (mark) => {
              let v = interpolateVariable(
                sizeGet,
                perCountryData.get(country),
                mark.attr('year')
              );
              return v > 0 ? Math.max(sizeScale(v), 0) : 0;
            },
            strokeWidth: () =>
              (selectedCountry == country ? 2.0 : 0) +
              (hoveredCountry == country ? 3.0 : 1.0),
            alpha: () =>
              selectedCountry == country ||
              (selectedCountry === null &&
                (hoveredCountry == country || hoveredCountry == null))
                ? 1.0
                : 0.3,
            labelSize: () =>
              selectedCountry == country || hoveredCountry == country
                ? 12.0
                : 0.0,
          })
      )
    );

    // create another render group for the line showing each country's trajectory
    // (these marks will only be added when the user hovers or selects, using the
    // stage manager)
    function createLine(id) {
      return new CP.Mark(id, {
        country: id,
        startYear: currentYear.get(),
        endYear: currentYear.get(),
        x: (mark) =>
          lineCoordinates(
            xGet,
            perCountryData.get(id),
            mark.attr('startYear'),
            mark.attr('endYear')
          ).map(scales.xScale),
        y: (mark) =>
          lineCoordinates(
            yGet,
            perCountryData.get(id),
            mark.attr('startYear'),
            mark.attr('endYear')
          ).map(scales.yScale),
        size: (mark) =>
          lineCoordinates(
            sizeGet,
            perCountryData.get(id),
            mark.attr('startYear'),
            mark.attr('endYear')
          ).map(sizeScale),
        alpha: 0.0,
      });
    }
    let lineSet = new CP.MarkRenderGroup()
      .configure({
        animationDuration: 500,
        animationCurve: CP.curveEaseInOut,
      })
      .configureStaging({
        enter: (mark) =>
          mark
            .animateTo('startYear', MinYear)
            .animateTo('endYear', MaxYear)
            .animateTo('alpha', 1.0, { duration: 200 })
            .wait(['startYear', 'endYear']),
        exit: (mark) =>
          mark
            .animateTo('startYear', currentYear.get())
            .animateTo('endYear', currentYear.get())
            .animateTo('alpha', 0.0, { duration: 200, delay: 300 })
            .wait(['startYear', 'endYear']),
      });

    let zoom = d3
      .zoom()
      .scaleExtent([0.1, 10])
      .on('zoom', (e) => {
        // important to make sure the source event exists, filtering out our
        // programmatic changes
        if (e.sourceEvent != null) scales.transform(e.transform);
      });
    d3.select(canvas).call(zoom);

    // the ticker runs every frame and redraws only when needed
    let ticker = new CP.Ticker([
      currentYear,
      bubbleSet,
      lineSet,
      scales,
    ]).onChange(() => {
      drawCanvas(canvas, bubbleSet, lineSet);
      slider.value = Math.round(currentYear.get());
      let yearLabel = document.getElementById('year-text');
      if (!!yearLabel) yearLabel.innerText = slider.value;
      if (bubbleSet.changed(['x', 'y'])) positionMap.invalidate();
    });
    // the position map keeps track of mark locations so we can find them on hover
    let positionMap = new CP.PositionMap().add(bubbleSet);

    // Function to zoom to a country, leaving room for that country's location in
    // all years
    let zoomToCountry = (country) =>
      scales.zoomTo(
        CP.markBox(
          Array.from(perCountryData.get(country).entries()).map(
            ([year, d]) =>
              new CP.Mark(`${country}-${year}`, {
                x: new CP.Attribute({
                  value: xGet(d),
                  transform: scales.xScale,
                }),
                y: new CP.Attribute({
                  value: yGet(d),
                  transform: scales.yScale,
                }),
              })
          ),
          { padding: 60 }
        )
      );

    let zoomToAll = (animated = true) =>
      scales.zoomTo(
        CP.markBox(bubbleSet.getMarks(), {
          padding: 60,
          inverseTransformCoordinates: true, // needed because we apply scale within the value fns
        }),
        animated
      );
    zoomToAll(false);

    // respond to year slider selections
    slider.addEventListener('input', (e) => {
      let newValue = e.target.value;

      if (newValue != currentYear) {
        currentYear.set(parseInt(newValue));
        bubbleSet.animate('year');
        positionMap.invalidate();
      }
    });

    // play/pause
    document.getElementById('play-pause').onclick = () => {
      if (currentYear.animating()) {
        currentYear.set(currentYear.get());
      } else {
        if (currentYear.get() >= MaxYear) currentYear.set(MinYear);
        currentYear.animate(
          new CP.basicAnimationTo(
            MaxYear,
            (MaxYear - currentYear.get()) * 500,
            CP.curveLinear
          )
        );
      }
    };

    // reset viewport to show all marks
    document.getElementById('reset-zoom').onclick = zoomToAll;

    // mouse event handlers for hovering and selecting
    let mouseDown = false;
    canvas.addEventListener('mousedown', () => (mouseDown = true));
    canvas.addEventListener('mousemove', (e) => {
      let mousePos = [
        e.clientX - canvas.getBoundingClientRect().left,
        e.clientY - canvas.getBoundingClientRect().top,
      ];
      if (!mouseDown) {
        let oldHover = hoveredCountry;
        hoveredCountry = nearestBubbleContainingPos(
          positionMap,
          mousePos,
          sizeScale.range()[1]
        );
        if (oldHover !== hoveredCountry) {
          bubbleSet.animate('strokeWidth', { duration: 200 });
          bubbleSet.animate('alpha', { duration: 200 });
          bubbleSet.animate('labelSize', { duration: 200 });
          if (oldHover != null && oldHover !== selectedCountry)
            lineSet.delete(oldHover);
          if (hoveredCountry != null && !lineSet.has(hoveredCountry))
            lineSet.addMark(
              lineSet.stage.get(hoveredCountry) ?? createLine(hoveredCountry)
            );
        }
      }
    });
    canvas.addEventListener('mouseup', () => (mouseDown = false));
    canvas.addEventListener('click', (e) => {
      let mousePos = [
        e.clientX - canvas.getBoundingClientRect().left,
        e.clientY - canvas.getBoundingClientRect().top,
      ];

      let oldSelection = selectedCountry;
      selectedCountry = nearestBubbleContainingPos(
        positionMap,
        mousePos,
        sizeScale.range()[1]
      );
      if (oldSelection !== selectedCountry) {
        bubbleSet.animate('alpha', { duration: 200 });
        bubbleSet.animate('strokeWidth', { duration: 200 });
        bubbleSet.animate('labelSize', { duration: 200 });
        if (oldSelection != null && lineSet.has(oldSelection))
          lineSet.deleteMark(lineSet.get(oldSelection));
        if (selectedCountry != null) {
          if (!lineSet.has(selectedCountry))
            lineSet.addMark(
              lineSet.stage.get(selectedCountry) ?? createLine(selectedCountry)
            );
          zoomToCountry(selectedCountry);
        }
      }
    });
    // on resize, update the chart bounds and redraw the canvas immediately to prevent flicker
    new ResizeObserver(() => {
      updateRanges(true);
      drawCanvas(canvas, bubbleSet, lineSet);
    }).observe(canvas);

    document.getElementById('x-dropdown').addEventListener('change', (e) => {
      xEncoding = e.target.value;
      updateDomains();
      bubbleSet.animate('x', { duration: 500 });
      lineSet.animate('x', { duration: 500 });
      bubbleSet.wait('x').then(() => zoomToAll(true));
    });
    document.getElementById('y-dropdown').addEventListener('change', (e) => {
      yEncoding = e.target.value;
      updateDomains();
      bubbleSet.animate('y', { duration: 500 });
      lineSet.animate('y', { duration: 500 });
      bubbleSet.wait('y').then(() => zoomToAll(true));
    });

    document.getElementById('size-dropdown').addEventListener('change', (e) => {
      sizeEncoding = e.target.value;
      updateDomains();
      bubbleSet.animate('radius', { duration: 500 });
      lineSet.animate('size', { duration: 500 });
      bubbleSet.wait('radius').then(() => zoomToAll(true));
    });
  });
}



import { ResponsiveChord } from '@nivo/chord'

const MyChord = ({ data /* see data tab */ }) => (
    <ResponsiveChord /* or Chord for fixed dimensions */
        data={data}
        keys={['John', 'Raoul', 'Jane', 'Marcel', 'Ibrahim']}
        margin={{ top: 60, right: 60, bottom: 90, left: 60 }}
        padAngle={0.06}
        legends={[
            {
                anchor: 'bottom',
                direction: 'row',
                translateY: 70,
                itemWidth: 80,
                itemHeight: 16,
                symbolShape: 'circle'
            }
        ]}
    />
)


import { ResponsiveFunnel } from '@nivo/funnel'

const MyFunnel = ({ data /* see data tab */ }) => (
    <ResponsiveFunnel /* or Funnel for fixed dimensions */
        data={data}
        margin={{ top: 20, right: 20, bottom: 20, left: 20 }}
        valueFormat=">-.4s"
        colors={{ scheme: 'spectral' }}
        borderWidth={20}
        labelColor={{ from: 'color', modifiers: [['darker', 3]] }}
        beforeSeparatorLength={100}
        beforeSeparatorOffset={20}
        afterSeparatorLength={100}
        afterSeparatorOffset={20}
        currentPartSizeExtension={10}
        currentBorderWidth={40}
    />
)


import { ResponsiveSankey } from '@nivo/sankey'

const MySankey = ({ data /* see data tab */ }) => (
    <ResponsiveSankey /* or Sankey for fixed dimensions */
        data={data}
        margin={{ top: 40, right: 160, bottom: 40, left: 50 }}
        align="justify"
        colors={{ scheme: 'category10' }}
        nodeOpacity={1}
        nodeHoverOthersOpacity={0.35}
        nodeThickness={18}
        nodeSpacing={24}
        nodeBorderWidth={0}
        nodeBorderColor={{ from: 'color', modifiers: [['darker', 0.8]] }}
        nodeBorderRadius={3}
        linkOpacity={0.5}
        linkHoverOthersOpacity={0.1}
        linkContract={3}
        enableLinkGradient={true}
        labelPosition="outside"
        labelOrientation="vertical"
        labelPadding={16}
        labelTextColor={{ from: 'color', modifiers: [['darker', 1]] }}
        legends={[
            {
                anchor: 'bottom-right',
                direction: 'column',
                translateX: 130,
                itemWidth: 100,
                itemHeight: 14,
                itemDirection: 'right-to-left',
                itemsSpacing: 2,
                itemTextColor: '#999',
                symbolSize: 14
            }
        ]}
    />
)



import { ResponsiveBump } from '@nivo/bump'

const MyBump = ({ data /* see data tab */ }) => (
    <ResponsiveBump /* or Bump for fixed dimensions */
        data={data}
        colors={{ scheme: 'spectral' }}
        lineWidth={3}
        activeLineWidth={6}
        inactiveLineWidth={3}
        inactiveOpacity={0.15}
        pointSize={10}
        activePointSize={16}
        inactivePointSize={0}
        pointColor={{ theme: 'background' }}
        pointBorderWidth={3}
        activePointBorderWidth={3}
        pointBorderColor={{ from: 'serie.color' }}
        axisLeft={{ legend: 'ranking', legendOffset: -40 }}
        margin={{ top: 40, right: 100, bottom: 40, left: 60 }}
    />
)



import { ResponsiveRadialBar } from '@nivo/radial-bar'

const MyRadialBar = ({ data /* see data tab */ }) => (
    <ResponsiveRadialBar /* or RadialBar for fixed dimensions */
        data={data}
        valueFormat=">-.2f"
        padding={0.4}
        cornerRadius={2}
        margin={{ top: 40, right: 120, bottom: 40, left: 40 }}
        radialAxisStart={{ tickSize: 5, tickPadding: 5, tickRotation: 0 }}
        circularAxisOuter={{ tickSize: 5, tickPadding: 12, tickRotation: 0 }}
        legends={[
            {
                anchor: 'right',
                direction: 'column',
                translateX: 80,
                itemsSpacing: 6,
                itemWidth: 100,
                itemHeight: 18
            }
        ]}
    />
)




// prettier-ignore
const hours = [
    '12a', '1a', '2a', '3a', '4a', '5a', '6a',
    '7a', '8a', '9a', '10a', '11a',
    '12p', '1p', '2p', '3p', '4p', '5p',
    '6p', '7p', '8p', '9p', '10p', '11p'
];
// prettier-ignore
const days = [
    'Saturday', 'Friday', 'Thursday',
    'Wednesday', 'Tuesday', 'Monday', 'Sunday'
];
// prettier-ignore
const data = [[0, 0, 5], [0, 1, 1], [0, 2, 0], [0, 3, 0], [0, 4, 0], [0, 5, 0], [0, 6, 0], [0, 7, 0], [0, 8, 0], [0, 9, 0], [0, 10, 0], [0, 11, 2], [0, 12, 4], [0, 13, 1], [0, 14, 1], [0, 15, 3], [0, 16, 4], [0, 17, 6], [0, 18, 4], [0, 19, 4], [0, 20, 3], [0, 21, 3], [0, 22, 2], [0, 23, 5], [1, 0, 7], [1, 1, 0], [1, 2, 0], [1, 3, 0], [1, 4, 0], [1, 5, 0], [1, 6, 0], [1, 7, 0], [1, 8, 0], [1, 9, 0], [1, 10, 5], [1, 11, 2], [1, 12, 2], [1, 13, 6], [1, 14, 9], [1, 15, 11], [1, 16, 6], [1, 17, 7], [1, 18, 8], [1, 19, 12], [1, 20, 5], [1, 21, 5], [1, 22, 7], [1, 23, 2], [2, 0, 1], [2, 1, 1], [2, 2, 0], [2, 3, 0], [2, 4, 0], [2, 5, 0], [2, 6, 0], [2, 7, 0], [2, 8, 0], [2, 9, 0], [2, 10, 3], [2, 11, 2], [2, 12, 1], [2, 13, 9], [2, 14, 8], [2, 15, 10], [2, 16, 6], [2, 17, 5], [2, 18, 5], [2, 19, 5], [2, 20, 7], [2, 21, 4], [2, 22, 2], [2, 23, 4], [3, 0, 7], [3, 1, 3], [3, 2, 0], [3, 3, 0], [3, 4, 0], [3, 5, 0], [3, 6, 0], [3, 7, 0], [3, 8, 1], [3, 9, 0], [3, 10, 5], [3, 11, 4], [3, 12, 7], [3, 13, 14], [3, 14, 13], [3, 15, 12], [3, 16, 9], [3, 17, 5], [3, 18, 5], [3, 19, 10], [3, 20, 6], [3, 21, 4], [3, 22, 4], [3, 23, 1], [4, 0, 1], [4, 1, 3], [4, 2, 0], [4, 3, 0], [4, 4, 0], [4, 5, 1], [4, 6, 0], [4, 7, 0], [4, 8, 0], [4, 9, 2], [4, 10, 4], [4, 11, 4], [4, 12, 2], [4, 13, 4], [4, 14, 4], [4, 15, 14], [4, 16, 12], [4, 17, 1], [4, 18, 8], [4, 19, 5], [4, 20, 3], [4, 21, 7], [4, 22, 3], [4, 23, 0], [5, 0, 2], [5, 1, 1], [5, 2, 0], [5, 3, 3], [5, 4, 0], [5, 5, 0], [5, 6, 0], [5, 7, 0], [5, 8, 2], [5, 9, 0], [5, 10, 4], [5, 11, 1], [5, 12, 5], [5, 13, 10], [5, 14, 5], [5, 15, 7], [5, 16, 11], [5, 17, 6], [5, 18, 0], [5, 19, 5], [5, 20, 3], [5, 21, 4], [5, 22, 2], [5, 23, 0], [6, 0, 1], [6, 1, 0], [6, 2, 0], [6, 3, 0], [6, 4, 0], [6, 5, 0], [6, 6, 0], [6, 7, 0], [6, 8, 0], [6, 9, 0], [6, 10, 1], [6, 11, 0], [6, 12, 2], [6, 13, 1], [6, 14, 3], [6, 15, 4], [6, 16, 0], [6, 17, 0], [6, 18, 0], [6, 19, 0], [6, 20, 1], [6, 21, 2], [6, 22, 2], [6, 23, 6]];
const title = [];
const singleAxis = [];
const series = [];
days.forEach(function (day, idx) {
  title.push({
    textBaseline: 'middle',
    top: ((idx + 0.5) * 100) / 7 + '%',
    text: day
  });
  singleAxis.push({
    left: 150,
    type: 'category',
    boundaryGap: false,
    data: hours,
    top: (idx * 100) / 7 + 5 + '%',
    height: 100 / 7 - 10 + '%',
    axisLabel: {
      interval: 2
    }
  });
  series.push({
    singleAxisIndex: idx,
    coordinateSystem: 'singleAxis',
    type: 'scatter',
    data: [],
    symbolSize: function (dataItem) {
      return dataItem[1] * 4;
    }
  });
});
data.forEach(function (dataItem) {
  series[dataItem[0]].data.push([dataItem[1], dataItem[2]]);
});
option = {
  tooltip: {
    position: 'top'
  },
  title: title,
  singleAxis: singleAxis,
  series: series
};



myChart.showLoading();
$.getJSON(ROOT_PATH + '/data/asset/data/les-miserables.json', function (graph) {
  myChart.hideLoading();
  graph.nodes.forEach(function (node) {
    node.label = {
      show: node.symbolSize > 30
    };
  });
  option = {
    title: {
      text: 'Les Miserables',
      subtext: 'Circular layout',
      top: 'bottom',
      left: 'right'
    },
    tooltip: {},
    legend: [
      {
        data: graph.categories.map(function (a) {
          return a.name;
        })
      }
    ],
    animationDurationUpdate: 1500,
    animationEasingUpdate: 'quinticInOut',
    series: [
      {
        name: 'Les Miserables',
        type: 'graph',
        layout: 'circular',
        circular: {
          rotateLabel: true
        },
        data: graph.nodes,
        links: graph.links,
        categories: graph.categories,
        roam: true,
        label: {
          position: 'right',
          formatter: '{b}'
        },
        lineStyle: {
          color: 'source',
          curveness: 0.3
        }
      }
    ]
  };
  myChart.setOption(option);
});



function getVirtualData(year) {
  const date = +echarts.time.parse(year + '-01-01');
  const end = +echarts.time.parse(+year + 1 + '-01-01');
  const dayTime = 3600 * 24 * 1000;
  const data = [];
  for (let time = date; time < end; time += dayTime) {
    data.push([
      echarts.time.format(time, '{yyyy}-{MM}-{dd}', false),
      Math.floor(Math.random() * 1000)
    ]);
  }
  return data;
}
option = {
  tooltip: {
    position: 'top',
    formatter: function (p) {
      const format = echarts.time.format(p.data[0], '{yyyy}-{MM}-{dd}', false);
      return format + ': ' + p.data[1];
    }
  },
  visualMap: {
    min: 0,
    max: 1000,
    calculable: true,
    orient: 'vertical',
    left: '670',
    top: 'center'
  },
  calendar: [
    {
      orient: 'vertical',
      range: '2015'
    },
    {
      left: 300,
      orient: 'vertical',
      range: '2016'
    },
    {
      left: 520,
      cellSize: [20, 'auto'],
      bottom: 10,
      orient: 'vertical',
      range: '2017',
      dayLabel: {
        margin: 5
      }
    }
  ],
  series: [
    {
      type: 'heatmap',
      coordinateSystem: 'calendar',
      calendarIndex: 0,
      data: getVirtualData('2015')
    },
    {
      type: 'heatmap',
      coordinateSystem: 'calendar',
      calendarIndex: 1,
      data: getVirtualData('2016')
    },
    {
      type: 'heatmap',
      coordinateSystem: 'calendar',
      calendarIndex: 2,
      data: getVirtualData('2017')
    }
  ]
};


$.when(
  $.get(ROOT_PATH + '/data/asset/data/option-view.json'),
  $.getScript(CDN_PATH + 'd3-hierarchy@2.0.0/dist/d3-hierarchy.min.js')
).done(function (res) {
  run(res[0]);
});
function run(rawData) {
  const dataWrap = prepareData(rawData);
  initChart(dataWrap.seriesData, dataWrap.maxDepth);
}
function prepareData(rawData) {
  const seriesData = [];
  let maxDepth = 0;
  function convert(source, basePath, depth) {
    if (source == null) {
      return;
    }
    if (maxDepth > 5) {
      return;
    }
    maxDepth = Math.max(depth, maxDepth);
    seriesData.push({
      id: basePath,
      value: source.$count,
      depth: depth,
      index: seriesData.length
    });
    for (var key in source) {
      if (source.hasOwnProperty(key) && !key.match(/^\$/)) {
        var path = basePath + '.' + key;
        convert(source[key], path, depth + 1);
      }
    }
  }
  convert(rawData, 'option', 0);
  return {
    seriesData: seriesData,
    maxDepth: maxDepth
  };
}
function initChart(seriesData, maxDepth) {
  var displayRoot = stratify();
  function stratify() {
    return d3
      .stratify()
      .parentId(function (d) {
        return d.id.substring(0, d.id.lastIndexOf('.'));
      })(seriesData)
      .sum(function (d) {
        return d.value || 0;
      })
      .sort(function (a, b) {
        return b.value - a.value;
      });
  }
  function overallLayout(params, api) {
    var context = params.context;
    d3
      .pack()
      .size([api.getWidth() - 2, api.getHeight() - 2])
      .padding(3)(displayRoot);
    context.nodes = {};
    displayRoot.descendants().forEach(function (node, index) {
      context.nodes[node.id] = node;
    });
  }
  function renderItem(params, api) {
    var context = params.context;
    // Only do that layout once in each time `setOption` called.
    if (!context.layout) {
      context.layout = true;
      overallLayout(params, api);
    }
    var nodePath = api.value('id');
    var node = context.nodes[nodePath];
    if (!node) {
      // Reder nothing.
      return;
    }
    var isLeaf = !node.children || !node.children.length;
    var focus = new Uint32Array(
      node.descendants().map(function (node) {
        return node.data.index;
      })
    );
    var nodeName = isLeaf
      ? nodePath
          .slice(nodePath.lastIndexOf('.') + 1)
          .split(/(?=[A-Z][^A-Z])/g)
          .join('\n')
      : '';
    var z2 = api.value('depth') * 2;
    return {
      type: 'circle',
      focus: focus,
      shape: {
        cx: node.x,
        cy: node.y,
        r: node.r
      },
      transition: ['shape'],
      z2: z2,
      textContent: {
        type: 'text',
        style: {
          // transition: isLeaf ? 'fontSize' : null,
          text: nodeName,
          fontFamily: 'Arial',
          width: node.r * 1.3,
          overflow: 'truncate',
          fontSize: node.r / 3
        },
        emphasis: {
          style: {
            overflow: null,
            fontSize: Math.max(node.r / 3, 12)
          }
        }
      },
      textConfig: {
        position: 'inside'
      },
      style: {
        fill: api.visual('color')
      },
      emphasis: {
        style: {
          fontFamily: 'Arial',
          fontSize: 12,
          shadowBlur: 20,
          shadowOffsetX: 3,
          shadowOffsetY: 5,
          shadowColor: 'rgba(0,0,0,0.3)'
        }
      }
    };
  }
  option = {
    dataset: {
      source: seriesData
    },
    tooltip: {},
    visualMap: [
      {
        show: false,
        min: 0,
        max: maxDepth,
        dimension: 'depth',
        inRange: {
          color: ['#006edd', '#e0ffff']
        }
      }
    ],
    hoverLayerThreshold: Infinity,
    series: {
      type: 'custom',
      renderItem: renderItem,
      progressive: 0,
      coordinateSystem: 'none',
      encode: {
        tooltip: 'value',
        itemName: 'id'
      }
    }
  };
  myChart.setOption(option);
  myChart.on('click', { seriesIndex: 0 }, function (params) {
    drillDown(params.data.id);
  });
  function drillDown(targetNodeId) {
    displayRoot = stratify();
    if (targetNodeId != null) {
      displayRoot = displayRoot.descendants().find(function (node) {
        return node.data.id === targetNodeId;
      });
    }
    // A trick to prevent d3-hierarchy from visiting parents in this algorithm.
    displayRoot.parent = null;
    myChart.setOption({
      dataset: {
        source: seriesData
      }
    });
  }
  // Reset: click on the blank area.
  myChart.getZr().on('click', function (event) {
    if (!event.target) {
      drillDown();
    }
  });
}



